<!-- Autogenerated by mlir-tblgen; don't manually edit -->
# Operation definition
## tf.Abs (TF::AbsOp)
Computes the absolute value of a tensor.

### Description:

Given a tensor `x`, this operation returns a tensor containing the absolute
value of each element in `x`. For example, if x is an input element and y is
an output element, this operation computes \\(y = |x|\\).

### Operands:
1. `x`: tensor of floating-point or 32/64-bit integer values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `T` | `Attribute` | derived attribute attribute |

### Results:
1. `y`: tensor of floating-point or 32/64-bit integer values

## tf.AddN (TF::AddNOp)
Add all input tensors element wise.

### Description:


### Operands:
1. `inputs`: tensor of bfloat16 type or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or complex128 type or complex64 type or TensorFlow variant type values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `N` | `IntegerAttr` | 64-bit integer attribute whose minimal value is 1 attribute |
| `T` | `Attribute` | derived attribute attribute |

### Results:
1. `sum`: tensor of bfloat16 type or 16-bit float or 32-bit float or 64-bit float or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or complex128 type or complex64 type or TensorFlow variant type values

## tf.Add (TF::AddOp)
Returns x + y element-wise.

### Description:

*NOTE*: `Add` supports broadcasting. `AddN` does not. More about broadcasting
[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)

### Operands:
1. `x`: tensor of number or TensorFlow string type values
1. `y`: tensor of number or TensorFlow string type values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `T` | `Attribute` | derived attribute attribute |

### Results:
1. `z`: tensor of number or TensorFlow string type values

## tf.AddV2 (TF::AddV2Op)
Returns x + y element-wise.

### Description:

*NOTE*: `Add` supports broadcasting. `AddN` does not. More about broadcasting
[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)

### Operands:
1. `x`: tensor of number values
1. `y`: tensor of number values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `T` | `Attribute` | derived attribute attribute |

### Results:
1. `z`: tensor of number values

## tf.AvgPool (TF::AvgPoolOp)
Performs average pooling on the input.

### Description:

Each entry in `output` is the mean of the corresponding size `ksize`
window in `value`.

### Operands:
1. `value`: tensor of floating-point values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `ksize` | `ArrayAttr` | 64-bit integer array attribute with at least 4 elements attribute |
| `strides` | `ArrayAttr` | 64-bit integer array attribute with at least 4 elements attribute |
| `padding` | `StringAttr` | string attribute whose value is SAME, or VALID attribute |
| `data_format` | `StringAttr` | 'NHWC' or 'NCHW' convnet data format attribute |
| `T` | `Attribute` | derived attribute attribute |

### Results:
1. `output`: tensor of floating-point values

## tf.BatchToSpaceND (TF::BatchToSpaceNDOp)
BatchToSpace for N-D tensors of type T.

### Description:

This operation reshapes the "batch" dimension 0 into `M + 1` dimensions of shape
`block_shape + [batch]`, interleaves these blocks back into the grid defined by
the spatial dimensions `[1, ..., M]`, to obtain a result with the same rank as
the input.  The spatial dimensions of this intermediate result are then
optionally cropped according to `crops` to produce the output.  This is the
reverse of SpaceToBatch.  See below for a precise description.

### Operands:
1. `input`: tensor of tf.dtype values
1. `block_shape`: tensor of 32/64-bit integer values
1. `crops`: tensor of 32/64-bit integer values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `T` | `Attribute` | derived attribute attribute |
| `Tcrops` | `Attribute` | derived attribute attribute |
| `Tblock_shape` | `Attribute` | derived attribute attribute |

### Results:
1. `output`: tensor of tf.dtype values

## tf.BiasAdd (TF::BiasAddOp)
Adds `bias` to `value`.

### Description:

This is a special case of `tf.add` where `bias` is restricted to be 1-D.
Broadcasting is supported, so `value` may have any number of dimensions.

### Operands:
1. `value`: tensor of number values
1. `bias`: tensor of number values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `data_format` | `StringAttr` | 'NHWC' or 'NCHW' convnet data format attribute |
| `T` | `Attribute` | derived attribute attribute |

### Results:
1. `output`: tensor of number values

## tf.Bitcast (TF::BitcastOp)

Bitcasts a tensor from one type to another without copying data.
  

### Description:

Given a tensor `input`, this operation returns a tensor that has the same buffer
data as `input` with datatype `type`.

If the input datatype `T` is larger than the output datatype `type` then the
shape changes from [...] to [..., sizeof(`T`)/sizeof(`type`)].

If `T` is smaller than `type`, the operator requires that the rightmost
dimension be equal to sizeof(`type`)/sizeof(`T`). The shape then goes from
[..., sizeof(`type`)/sizeof(`T`)] to [...].

tf.bitcast() and tf.cast() work differently when real dtype is casted as a complex dtype
(e.g. tf.complex64 or tf.complex128) as tf.cast() make imaginary part 0 while tf.bitcast()
gives module error.
For example,

Example 1:

```python
>>> a = [1., 2., 3.]
>>> equality_bitcast = tf.bitcast(a,tf.complex128)
tensorflow.python.framework.errors_impl.InvalidArgumentError: Cannot bitcast from float to complex128: shape [3] [Op:Bitcast]
>>> equality_cast = tf.cast(a,tf.complex128)
>>> print(equality_cast)
tf.Tensor([1.+0.j 2.+0.j 3.+0.j], shape=(3,), dtype=complex128)
```

Example 2:

```python
>>> tf.bitcast(tf.constant(0xffffffff, dtype=tf.uint32), tf.uint8)
<tf.Tensor: ... shape=(4,), dtype=uint8, numpy=array([255, 255, 255, 255], dtype=uint8)>
```

Example 3:

```python
>>> x = [1., 2., 3.]
>>> y = [0., 2., 3.]
>>> equality= tf.equal(x,y)
>>> equality_cast = tf.cast(equality,tf.float32)
>>> equality_bitcast = tf.bitcast(equality_cast,tf.uint8)
>>> print(equality)
tf.Tensor([False True True], shape=(3,), dtype=bool)
>>> print(equality_cast)
tf.Tensor([0. 1. 1.], shape=(3,), dtype=float32)
>>> print(equality_bitcast)
tf.Tensor(
[[ 0 0 0 0]
 [ 0 0 128 63]
 [ 0 0 128 63]], shape=(3, 4), dtype=uint8)
```

*NOTE*: Bitcast is implemented as a low-level cast, so machines with different
endian orderings will give different results.

### Operands:
1. `input`: tensor of number values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `T` | `Attribute` | derived attribute attribute |
| `type` | `Attribute` | derived attribute attribute |

### Results:
1. `output`: tensor of number values

## tf.BroadcastTo (TF::BroadcastToOp)
Broadcast an array for a compatible shape.

### Description:

Broadcasting is the process of making arrays to have compatible shapes
for arithmetic operations. Two shapes are compatible if for each
dimension pair they are either equal or one of them is one. When trying
to broadcast a Tensor to a shape, it starts with the trailing dimensions,
and works its way forward.

For example,

```python
>>> x = tf.constant([1, 2, 3])
>>> y = tf.broadcast_to(x, [3, 3])
>>> sess.run(y)
array([[1, 2, 3],
       [1, 2, 3],
       [1, 2, 3]], dtype=int32)
```

In the above example, the input Tensor with the shape of `[1, 3]`
is broadcasted to output Tensor with shape of `[3, 3]`.

### Operands:
1. `input`: tensor of tf.dtype values
1. `shape`: tensor of 32/64-bit integer values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `T` | `Attribute` | derived attribute attribute |
| `Tidx` | `Attribute` | derived attribute attribute |

### Results:
1. `output`: tensor of tf.dtype values

## tf.Cast (TF::CastOp)
Cast x of type SrcT to y of DstT.

### Description:


### Operands:
1. `x`: tensor of tf.dtype values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `Truncate` | `BoolAttr` | bool attribute attribute |
| `SrcT` | `Attribute` | derived attribute attribute |
| `DstT` | `Attribute` | derived attribute attribute |

### Results:
1. `y`: tensor of tf.dtype values

## tf.Ceil (TF::CeilOp)
Returns element-wise smallest integer not less than x.

### Description:


### Operands:
1. `x`: tensor of floating-point values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `T` | `Attribute` | derived attribute attribute |

### Results:
1. `y`: tensor of floating-point values

## tf.Concat (TF::ConcatOp)
Concatenates tensors along one dimension.

### Description:


### Operands:
1. `concat_dim`: tensor of 32-bit integer values
1. `values`: tensor of tf.dtype values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `N` | `IntegerAttr` | 64-bit integer attribute whose minimal value is 2 attribute |
| `T` | `Attribute` | derived attribute attribute |

### Results:
1. `output`: tensor of tf.dtype values

## tf.ConcatV2 (TF::ConcatV2Op)
Concatenates tensors along one dimension.

### Description:


### Operands:
1. `values`: tensor of tf.dtype values
1. `axis`: tensor of 32/64-bit integer values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `N` | `IntegerAttr` | 64-bit integer attribute whose minimal value is 2 attribute |
| `T` | `Attribute` | derived attribute attribute |
| `Tidx` | `Attribute` | derived attribute attribute |

### Results:
1. `output`: tensor of tf.dtype values

## tf.Conj (TF::ConjOp)
Returns the complex conjugate of a complex number.

### Description:

Given a tensor `input` of complex numbers, this operation returns a tensor of
complex numbers that are the complex conjugate of each element in `input`. The
complex numbers in `input` must be of the form \\(a + bj\\), where *a* is the
real part and *b* is the imaginary part.

The complex conjugate returned by this operation is of the form \\(a - bj\\).

For example:

```
# tensor 'input' is [-2.25 + 4.75j, 3.25 + 5.75j]
tf.conj(input) ==> [-2.25 - 4.75j, 3.25 - 5.75j]
```

### Operands:
1. `input`: tensor of complex128 type or complex64 type or TensorFlow variant type values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `T` | `Attribute` | derived attribute attribute |

### Results:
1. `output`: tensor of complex128 type or complex64 type or TensorFlow variant type values

## tf.Const (TF::ConstOp)
Constant tensor op

### Description:


### Operands:

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `value` | `ElementsAttr` | constant vector/tensor attribute attribute |
| `dtype` | `Attribute` | derived attribute attribute |

### Results:
1. `output`: tensor of tf.dtype values

## tf.Conv2D (TF::Conv2DOp)

Computes a 2-D convolution given 4-D `input` and `filter` tensors.
  

### Description:

Given an input tensor of shape `[batch, in_height, in_width, in_channels]`
and a filter / kernel tensor of shape
`[filter_height, filter_width, in_channels, out_channels]`, this op
performs the following:

1. Flattens the filter to a 2-D matrix with shape
   `[filter_height * filter_width * in_channels, output_channels]`.
2. Extracts image patches from the input tensor to form a *virtual*
   tensor of shape `[batch, out_height, out_width,
   filter_height * filter_width * in_channels]`.
3. For each patch, right-multiplies the filter matrix and the image patch
   vector.

In detail, with the default NHWC format,

    output[b, i, j, k] =
        sum_{di, dj, q} input[b, strides[1] * i + di, strides[2] * j + dj, q] *
                        filter[di, dj, q, k]

Must have `strides[0] = strides[3] = 1`.  For the most common case of the same
horizontal and vertices strides, `strides = [1, stride, stride, 1]`.

### Operands:
1. `input`: tensor of floating-point values
1. `filter`: tensor of floating-point values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `strides` | `ArrayAttr` | 64-bit integer array attribute attribute |
| `use_cudnn_on_gpu` | `BoolAttr` | bool attribute attribute |
| `padding` | `StringAttr` | string attribute whose value is SAME, or VALID, or EXPLICIT attribute |
| `explicit_paddings` | `ArrayAttr` | 64-bit integer array attribute attribute |
| `data_format` | `StringAttr` | 'NHWC' or 'NCHW' convnet data format attribute |
| `dilations` | `ArrayAttr` | 64-bit integer array attribute attribute |
| `T` | `Attribute` | derived attribute attribute |

### Results:
1. `output`: tensor of floating-point values

## tf.Cos (TF::CosOp)
Computes cos of x element-wise.

### Description:


### Operands:
1. `x`: tensor of floating-point or 64/128-bit complex type values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `T` | `Attribute` | derived attribute attribute |

### Results:
1. `y`: tensor of floating-point or 64/128-bit complex type values

## tf.DepthwiseConv2dNative (TF::DepthwiseConv2dNativeOp)

Computes a 2-D depthwise convolution given 4-D `input` and `filter` tensors.
  

### Description:

Given an input tensor of shape `[batch, in_height, in_width, in_channels]`
and a filter / kernel tensor of shape
`[filter_height, filter_width, in_channels, channel_multiplier]`, containing
`in_channels` convolutional filters of depth 1, `depthwise_conv2d` applies
a different filter to each input channel (expanding from 1 channel to
`channel_multiplier` channels for each), then concatenates the results
together. Thus, the output has `in_channels * channel_multiplier` channels.

```
for k in 0..in_channels-1
  for q in 0..channel_multiplier-1
    output[b, i, j, k * channel_multiplier + q] =
      sum_{di, dj} input[b, strides[1] * i + di, strides[2] * j + dj, k] *
                        filter[di, dj, k, q]
```

Must have `strides[0] = strides[3] = 1`.  For the most common case of the same
horizontal and vertices strides, `strides = [1, stride, stride, 1]`.

### Operands:
1. `input`: tensor of floating-point values
1. `filter`: tensor of floating-point values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `strides` | `ArrayAttr` | 64-bit integer array attribute attribute |
| `padding` | `StringAttr` | string attribute whose value is SAME, or VALID attribute |
| `data_format` | `StringAttr` | 'NHWC' or 'NCHW' convnet data format attribute |
| `dilations` | `ArrayAttr` | 64-bit integer array attribute attribute |
| `T` | `Attribute` | derived attribute attribute |

### Results:
1. `output`: tensor of floating-point values

## tf.Div (TF::DivOp)
Returns x / y element-wise.

### Description:

*NOTE*: `Div` supports broadcasting. More about broadcasting
[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)

### Operands:
1. `x`: tensor of number values
1. `y`: tensor of number values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `T` | `Attribute` | derived attribute attribute |

### Results:
1. `z`: tensor of number values

## tf.Elu (TF::EluOp)

Computes exponential linear: `exp(features) - 1` if < 0, `features` otherwise.
  

### Description:

See [Fast and Accurate Deep Network Learning by Exponential Linear Units (ELUs)
](http://arxiv.org/abs/1511.07289)

### Operands:
1. `features`: tensor of floating-point values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `T` | `Attribute` | derived attribute attribute |

### Results:
1. `activations`: tensor of floating-point values

## tf.Equal (TF::EqualOp)
Returns the truth value of (x == y) element-wise.

### Description:

*NOTE*: `Equal` supports broadcasting. More about broadcasting
[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)

```python
x = tf.constant([2, 4])
y = tf.constant(2)
tf.math.equal(x, y) ==> array([True, False])

x = tf.constant([2, 4])
y = tf.constant([2, 4])
tf.math.equal(x, y) ==> array([True,  True])
```

### Operands:
1. `x`: tensor of bfloat16 type or 16-bit float or 32-bit float or 64-bit float or 1-bit integer or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or complex128 type or complex64 type or TensorFlow string type values
1. `y`: tensor of bfloat16 type or 16-bit float or 32-bit float or 64-bit float or 1-bit integer or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or complex128 type or complex64 type or TensorFlow string type values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `T` | `Attribute` | derived attribute attribute |

### Results:
1. `z`: tensor of 1-bit integer values

## tf.ExpandDims (TF::ExpandDimsOp)
Inserts a dimension of 1 into a tensor's shape.

### Description:

Given a tensor `input`, this operation inserts a dimension of 1 at the
dimension index `axis` of `input`'s shape. The dimension index `axis` starts at
zero; if you specify a negative number for `axis` it is counted backward from
the end.

This operation is useful if you want to add a batch dimension to a single
element. For example, if you have a single image of shape `[height, width,
channels]`, you can make it a batch of 1 image with `expand_dims(image, 0)`,
which will make the shape `[1, height, width, channels]`.

Other examples:

```
# 't' is a tensor of shape [2]
shape(expand_dims(t, 0)) ==> [1, 2]
shape(expand_dims(t, 1)) ==> [2, 1]
shape(expand_dims(t, -1)) ==> [2, 1]

# 't2' is a tensor of shape [2, 3, 5]
shape(expand_dims(t2, 0)) ==> [1, 2, 3, 5]
shape(expand_dims(t2, 2)) ==> [2, 3, 1, 5]
shape(expand_dims(t2, 3)) ==> [2, 3, 5, 1]
```

This operation requires that:

`-1-input.dims() <= dim <= input.dims()`

This operation is related to `squeeze()`, which removes dimensions of
size 1.

### Operands:
1. `input`: tensor of tf.dtype values
1. `dim`: tensor of 32/64-bit integer values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `T` | `Attribute` | derived attribute attribute |
| `Tdim` | `Attribute` | derived attribute attribute |

### Results:
1. `output`: tensor of tf.dtype values

## tf.FakeQuantWithMinMaxArgs (TF::FakeQuantWithMinMaxArgsOp)

Fake-quantize the 'inputs' tensor, type float to 'outputs' tensor of same type.
  

### Description:

Attributes `[min; max]` define the clamping range for the `inputs` data.
`inputs` values are quantized into the quantization range (`[0; 2^num_bits - 1]`
when `narrow_range` is false and `[1; 2^num_bits - 1]` when it is true) and
then de-quantized and output as floats in `[min; max]` interval.
`num_bits` is the bitwidth of the quantization; between 2 and 16, inclusive.

Before quantization, `min` and `max` values are adjusted with the following
logic.
It is suggested to have `min <= 0 <= max`. If `0` is not in the range of values,
the behavior can be unexpected:
If `0 < min < max`: `min_adj = 0` and `max_adj = max - min`.
If `min < max < 0`: `min_adj = min - max` and `max_adj = 0`.
If `min <= 0 <= max`: `scale = (max - min) / (2^num_bits - 1) `,
`min_adj = scale * round(min / scale)` and `max_adj = max + min_adj - min`.

Quantization is called fake since the output is still in floating point.

### Operands:
1. `inputs`: tensor of 32-bit float values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `min` | `FloatAttr` | 32-bit float attribute attribute |
| `max` | `FloatAttr` | 32-bit float attribute attribute |
| `num_bits` | `IntegerAttr` | 64-bit integer attribute attribute |
| `narrow_range` | `BoolAttr` | bool attribute attribute |

### Results:
1. `outputs`: tensor of 32-bit float values

## tf.FakeQuantWithMinMaxVars (TF::FakeQuantWithMinMaxVarsOp)

Fake-quantize the 'inputs' tensor of type float via global float scalars `min`
  

### Description:

and `max` to 'outputs' tensor of same shape as `inputs`.

`[min; max]` define the clamping range for the `inputs` data.
`inputs` values are quantized into the quantization range (`[0; 2^num_bits - 1]`
when `narrow_range` is false and `[1; 2^num_bits - 1]` when it is true) and
then de-quantized and output as floats in `[min; max]` interval.
`num_bits` is the bitwidth of the quantization; between 2 and 16, inclusive.

Before quantization, `min` and `max` values are adjusted with the following
logic.
It is suggested to have `min <= 0 <= max`. If `0` is not in the range of values,
the behavior can be unexpected:
If `0 < min < max`: `min_adj = 0` and `max_adj = max - min`.
If `min < max < 0`: `min_adj = min - max` and `max_adj = 0`.
If `min <= 0 <= max`: `scale = (max - min) / (2^num_bits - 1) `,
`min_adj = scale * round(min / scale)` and `max_adj = max + min_adj - min`.

This operation has a gradient and thus allows for training `min` and `max`
values.

### Operands:
1. `inputs`: tensor of 32-bit float values
1. `min`: tensor of 32-bit float values
1. `max`: tensor of 32-bit float values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `num_bits` | `IntegerAttr` | 64-bit integer attribute attribute |
| `narrow_range` | `BoolAttr` | bool attribute attribute |

### Results:
1. `outputs`: tensor of 32-bit float values

## tf.Fill (TF::FillOp)
Creates a tensor filled with a scalar value.

### Description:

This operation creates a tensor of shape `dims` and fills it with `value`.

For example:

```
# Output tensor has shape [2, 3].
fill([2, 3], 9) ==> [[9, 9, 9]
                     [9, 9, 9]]
```

`tf.fill` differs from `tf.constant` in a few ways:

*   `tf.fill` only supports scalar contents, whereas `tf.constant` supports
    Tensor values.
*   `tf.fill` creates an Op in the computation graph that constructs the actual
    Tensor value at runtime. This is in contrast to `tf.constant` which embeds
    the entire Tensor into the graph with a `Const` node.
*   Because `tf.fill` evaluates at graph runtime, it supports dynamic shapes
    based on other runtime Tensors, unlike `tf.constant`.

### Operands:
1. `dims`: tensor of 32/64-bit integer values
1. `value`: tensor of tf.dtype values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `T` | `Attribute` | derived attribute attribute |
| `index_type` | `Attribute` | derived attribute attribute |

### Results:
1. `output`: tensor of tf.dtype values

## tf.FloorDiv (TF::FloorDivOp)
Returns x // y element-wise.

### Description:

*NOTE*: `FloorDiv` supports broadcasting. More about broadcasting
[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)

### Operands:
1. `x`: tensor of number values
1. `y`: tensor of number values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `T` | `Attribute` | derived attribute attribute |

### Results:
1. `z`: tensor of number values

## tf.Floor (TF::FloorOp)
Returns element-wise largest integer not greater than x.

### Description:


### Operands:
1. `x`: tensor of floating-point values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `T` | `Attribute` | derived attribute attribute |

### Results:
1. `y`: tensor of floating-point values

## tf.FusedBatchNorm (TF::FusedBatchNormOp)
Batch normalization.

### Description:

Note that the size of 4D Tensors are defined by either "NHWC" or "NCHW".
The size of 1D Tensors matches the dimension C of the 4D Tensors.

### Operands:
1. `x`: tensor of 32-bit float values
1. `scale`: tensor of 32-bit float values
1. `offset`: tensor of 32-bit float values
1. `mean`: tensor of 32-bit float values
1. `variance`: tensor of 32-bit float values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `epsilon` | `FloatAttr` | 32-bit float attribute attribute |
| `data_format` | `StringAttr` | 'NHWC' or 'NCHW' convnet data format attribute |
| `is_training` | `BoolAttr` | bool attribute attribute |
| `T` | `Attribute` | derived attribute attribute |

### Results:
1. `y`: tensor of 32-bit float values
1. `batch_mean`: tensor of 32-bit float values
1. `batch_variance`: tensor of 32-bit float values
1. `reserve_space_1`: tensor of 32-bit float values
1. `reserve_space_2`: tensor of 32-bit float values

## tf.Gather (TF::GatherOp)
Gather slices from `params` according to `indices`.

### Description:

`indices` must be an integer tensor of any dimension (usually 0-D or 1-D).
Produces an output tensor with shape `indices.shape + params.shape[1:]` where:

```python
    # Scalar indices
    output[:, ..., :] = params[indices, :, ... :]

    # Vector indices
    output[i, :, ..., :] = params[indices[i], :, ... :]

    # Higher rank indices
    output[i, ..., j, :, ... :] = params[indices[i, ..., j], :, ..., :]
```

If `indices` is a permutation and `len(indices) == params.shape[0]` then
this operation will permute `params` accordingly.

`validate_indices`: DEPRECATED. If this operation is assigned to CPU, values in
`indices` are always validated to be within range. If assigned to GPU,
out-of-bound indices result in safe but unspecified behavior, which may include
raising an error.

<div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;">
<img style="width:100%" src="https://www.tensorflow.org/images/Gather.png" alt>
</div>

### Operands:
1. `params`: tensor of tf.dtype values
1. `indices`: tensor of 32/64-bit integer values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `validate_indices` | `BoolAttr` | bool attribute attribute |
| `Tindices` | `Attribute` | derived attribute attribute |
| `Tparams` | `Attribute` | derived attribute attribute |

### Results:
1. `output`: tensor of tf.dtype values

## tf.GatherV2 (TF::GatherV2Op)

Gather slices from `params` axis `axis` according to `indices`.
  

### Description:

`indices` must be an integer tensor of any dimension (usually 0-D or 1-D).
Produces an output tensor with shape `params.shape[:axis] + indices.shape +
params.shape[axis + 1:]` where:

```python
    # Scalar indices (output is rank(params) - 1).
    output[a_0, ..., a_n, b_0, ..., b_n] =
      params[a_0, ..., a_n, indices, b_0, ..., b_n]

    # Vector indices (output is rank(params)).
    output[a_0, ..., a_n, i, b_0, ..., b_n] =
      params[a_0, ..., a_n, indices[i], b_0, ..., b_n]

    # Higher rank indices (output is rank(params) + rank(indices) - 1).
    output[a_0, ..., a_n, i, ..., j, b_0, ... b_n] =
      params[a_0, ..., a_n, indices[i, ..., j], b_0, ..., b_n]
```

<div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;">
<img style="width:100%" src="https://www.tensorflow.org/images/Gather.png" alt>
</div>

Note that on CPU, if an out of bound index is found, an error is returned.
On GPU, if an out of bound index is found, a 0 is stored in the
corresponding output value.

See also `tf.batch_gather` and `tf.gather_nd`.

### Operands:
1. `params`: tensor of tf.dtype values
1. `indices`: tensor of 32/64-bit integer values
1. `axis`: tensor of 32/64-bit integer values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `batch_dims` | `IntegerAttr` | 64-bit integer attribute attribute |
| `Tindices` | `Attribute` | derived attribute attribute |
| `Tparams` | `Attribute` | derived attribute attribute |
| `Taxis` | `Attribute` | derived attribute attribute |

### Results:
1. `output`: tensor of tf.dtype values

## tf.GreaterEqual (TF::GreaterEqualOp)
Returns the truth value of (x >= y) element-wise.

### Description:

*NOTE*: `GreaterEqual` supports broadcasting. More about broadcasting
[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)

### Operands:
1. `x`: tensor of 8/16/32/64-bit integer or floating-point values
1. `y`: tensor of 8/16/32/64-bit integer or floating-point values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `T` | `Attribute` | derived attribute attribute |

### Results:
1. `z`: tensor of 1-bit integer values

## tf.Greater (TF::GreaterOp)
Returns the truth value of (x > y) element-wise.

### Description:

*NOTE*: `Greater` supports broadcasting. More about broadcasting
[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)

### Operands:
1. `x`: tensor of 8/16/32/64-bit integer or floating-point values
1. `y`: tensor of 8/16/32/64-bit integer or floating-point values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `T` | `Attribute` | derived attribute attribute |

### Results:
1. `z`: tensor of 1-bit integer values

## tf.IdentityN (TF::IdentityNOp)

Returns a list of tensors with the same shapes and contents as the input
  

### Description:

tensors.

This op can be used to override the gradient for complicated functions. For
example, suppose y = f(x) and we wish to apply a custom function g for backprop
such that dx = g(dy). In Python,

```python
with tf.get_default_graph().gradient_override_map(
    {'IdentityN': 'OverrideGradientWithG'}):
  y, _ = identity_n([f(x), x])

@tf.RegisterGradient('OverrideGradientWithG')
def ApplyG(op, dy, _):
  return [None, g(dy)]  # Do not backprop to f(x).
```

### Operands:
1. `input`: tensor of tf.dtype values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `T` | `Attribute` | derived attribute attribute |

### Results:
1. `output`: tensor of tf.dtype values

## tf.Identity (TF::IdentityOp)
Identity op

### Description:

Returns a tensor with the same shape and contents as input.

### Operands:
1. `input`: tensor of tf.dtype values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `T` | `Attribute` | derived attribute attribute |

### Results:
1. `output`: tensor of tf.dtype values

## tf.Invert (TF::InvertOp)

Invert (flip) each bit of supported types; for example, type `uint8` value 01010101 becomes 10101010.
  

### Description:

Flip each bit of supported types.  For example, type `int8` (decimal 2) binary 00000010 becomes (decimal -3) binary 11111101.
This operation is performed on each element of the tensor argument `x`.

### Operands:
1. `x`: tensor of 8/16/32/64-bit integer values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `T` | `Attribute` | derived attribute attribute |

### Results:
1. `y`: tensor of 8/16/32/64-bit integer values

## tf.LeakyRelu (TF::LeakyReluOp)
Computes rectified linear: `max(features, features * alpha)`.

### Description:


### Operands:
1. `features`: tensor of floating-point values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `alpha` | `FloatAttr` | 32-bit float attribute attribute |
| `T` | `Attribute` | derived attribute attribute |

### Results:
1. `activations`: tensor of floating-point values

## tf.LessEqual (TF::LessEqualOp)
Returns the truth value of (x <= y) element-wise.

### Description:

*NOTE*: `LessEqual` supports broadcasting. More about broadcasting
[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)

### Operands:
1. `x`: tensor of 8/16/32/64-bit integer or floating-point values
1. `y`: tensor of 8/16/32/64-bit integer or floating-point values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `T` | `Attribute` | derived attribute attribute |

### Results:
1. `z`: tensor of 1-bit integer values

## tf.Less (TF::LessOp)
Returns the truth value of (x < y) element-wise.

### Description:

*NOTE*: `Less` supports broadcasting. More about broadcasting
[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)

### Operands:
1. `x`: tensor of 8/16/32/64-bit integer or floating-point values
1. `y`: tensor of 8/16/32/64-bit integer or floating-point values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `T` | `Attribute` | derived attribute attribute |

### Results:
1. `z`: tensor of 1-bit integer values

## tf.Log (TF::LogOp)
Computes natural logarithm of x element-wise.

### Description:

I.e., \\(y = \log_e x\\).

### Operands:
1. `x`: tensor of floating-point or 64/128-bit complex type values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `T` | `Attribute` | derived attribute attribute |

### Results:
1. `y`: tensor of floating-point or 64/128-bit complex type values

## tf.LogSoftmax (TF::LogSoftmaxOp)
Computes log softmax activations.

### Description:

For each batch `i` and class `j` we have

    logsoftmax[i, j] = logits[i, j] - log(sum(exp(logits[i])))

### Operands:
1. `logits`: tensor of floating-point values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `T` | `Attribute` | derived attribute attribute |

### Results:
1. `logsoftmax`: tensor of floating-point values

## tf.LogicalAnd (TF::LogicalAndOp)
Returns the truth value of x AND y element-wise.

### Description:

*NOTE*: `LogicalAnd` supports broadcasting. More about broadcasting
[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)

### Operands:
1. `x`: tensor of 1-bit integer values
1. `y`: tensor of 1-bit integer values

### Attributes:

### Results:
1. `z`: tensor of 1-bit integer values

## tf.LogicalNot (TF::LogicalNotOp)
Returns the truth value of NOT x element-wise.

### Description:


### Operands:
1. `x`: tensor of 1-bit integer values

### Attributes:

### Results:
1. `y`: tensor of 1-bit integer values

## tf.LogicalOr (TF::LogicalOrOp)
Returns the truth value of x OR y element-wise.

### Description:

*NOTE*: `LogicalOr` supports broadcasting. More about broadcasting
[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)

### Operands:
1. `x`: tensor of 1-bit integer values
1. `y`: tensor of 1-bit integer values

### Attributes:

### Results:
1. `z`: tensor of 1-bit integer values

## tf.MatMul (TF::MatMulOp)

Multiply the matrix "a" by the matrix "b".
  

### Description:

The inputs must be two-dimensional matrices and the inner dimension of
"a" (after being transposed if transpose_a is true) must match the
outer dimension of "b" (after being transposed if transposed_b is
true).

*Note*: The default kernel implementation for MatMul on GPUs uses
cublas.

### Operands:
1. `a`: tensor of bfloat16 type or 16-bit float or 32-bit float or 64-bit float or 32-bit integer or 64-bit integer or complex128 type or complex64 type values
1. `b`: tensor of bfloat16 type or 16-bit float or 32-bit float or 64-bit float or 32-bit integer or 64-bit integer or complex128 type or complex64 type values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `transpose_a` | `BoolAttr` | bool attribute attribute |
| `transpose_b` | `BoolAttr` | bool attribute attribute |
| `T` | `Attribute` | derived attribute attribute |

### Results:
1. `product`: tensor of bfloat16 type or 16-bit float or 32-bit float or 64-bit float or 32-bit integer or 64-bit integer or complex128 type or complex64 type values

## tf.Max (TF::MaxOp)

Computes the maximum of elements across dimensions of a tensor.
  

### Description:

Reduces `input` along the dimensions given in `axis`. Unless
`keep_dims` is true, the rank of the tensor is reduced by 1 for each entry in
`axis`. If `keep_dims` is true, the reduced dimensions are
retained with length 1.

### Operands:
1. `input`: tensor of number values
1. `reduction_indices`: tensor of 32/64-bit integer values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `keep_dims` | `BoolAttr` | bool attribute attribute |
| `T` | `Attribute` | derived attribute attribute |
| `Tidx` | `Attribute` | derived attribute attribute |

### Results:
1. `output`: tensor of number values

## tf.MaxPool (TF::MaxPoolOp)
Performs max pooling on the input.

### Description:


### Operands:
1. `input`: tensor of 8/16/32/64-bit integer or floating-point values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `ksize` | `ArrayAttr` | 64-bit integer array attribute with at least 4 elements attribute |
| `strides` | `ArrayAttr` | 64-bit integer array attribute with at least 4 elements attribute |
| `padding` | `StringAttr` | string attribute whose value is SAME, or VALID attribute |
| `data_format` | `StringAttr` | string attribute whose value is NHWC, or NCHW, or NCHW_VECT_C attribute |
| `T` | `Attribute` | derived attribute attribute |

### Results:
1. `output`: tensor of 8/16/32/64-bit integer or floating-point values

## tf.Maximum (TF::MaximumOp)
Returns the max of x and y (i.e. x > y ? x : y) element-wise.

### Description:

*NOTE*: `Maximum` supports broadcasting. More about broadcasting
[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)

### Operands:
1. `x`: tensor of floating-point or 32/64-bit integer values
1. `y`: tensor of floating-point or 32/64-bit integer values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `T` | `Attribute` | derived attribute attribute |

### Results:
1. `z`: tensor of floating-point or 32/64-bit integer values

## tf.Mean (TF::MeanOp)
Computes the mean of elements across dimensions of a tensor.

### Description:

Reduces `input` along the dimensions given in `axis`. Unless
`keep_dims` is true, the rank of the tensor is reduced by 1 for each entry in
`axis`. If `keep_dims` is true, the reduced dimensions are
retained with length 1.

### Operands:
1. `input`: tensor of number values
1. `reduction_indices`: tensor of 32/64-bit integer values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `keep_dims` | `BoolAttr` | bool attribute attribute |
| `T` | `Attribute` | derived attribute attribute |
| `Tidx` | `Attribute` | derived attribute attribute |

### Results:
1. `output`: tensor of number values

## tf.Min (TF::MinOp)

Computes the minimum of elements across dimensions of a tensor.
  

### Description:

Reduces `input` along the dimensions given in `axis`. Unless
`keep_dims` is true, the rank of the tensor is reduced by 1 for each entry in
`axis`. If `keep_dims` is true, the reduced dimensions are
retained with length 1.

### Operands:
1. `input`: tensor of number values
1. `reduction_indices`: tensor of 32/64-bit integer values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `keep_dims` | `BoolAttr` | bool attribute attribute |
| `T` | `Attribute` | derived attribute attribute |
| `Tidx` | `Attribute` | derived attribute attribute |

### Results:
1. `output`: tensor of number values

## tf.Minimum (TF::MinimumOp)
Returns the min of x and y (i.e. x < y ? x : y) element-wise.

### Description:

*NOTE*: `Minimum` supports broadcasting. More about broadcasting
[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)

### Operands:
1. `x`: tensor of floating-point or 32/64-bit integer values
1. `y`: tensor of floating-point or 32/64-bit integer values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `T` | `Attribute` | derived attribute attribute |

### Results:
1. `z`: tensor of floating-point or 32/64-bit integer values

## tf.MulNoNan (TF::MulNoNanOp)

Returns x * y element-wise. Returns zero if y is zero, even if x if infinite or NaN.
  

### Description:

*NOTE*: `MulNoNan` supports broadcasting. More about broadcasting
[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)

### Operands:
1. `x`: tensor of 16-bit float or 32-bit float or 64-bit float or complex128 type or complex64 type values
1. `y`: tensor of 16-bit float or 32-bit float or 64-bit float or complex128 type or complex64 type values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `T` | `Attribute` | derived attribute attribute |

### Results:
1. `z`: tensor of 16-bit float or 32-bit float or 64-bit float or complex128 type or complex64 type values

## tf.Mul (TF::MulOp)
Returns x * y element-wise.

### Description:

*NOTE*: `Multiply` supports broadcasting. More about broadcasting
[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)

### Operands:
1. `x`: tensor of number values
1. `y`: tensor of number values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `T` | `Attribute` | derived attribute attribute |

### Results:
1. `z`: tensor of number values

## tf.Neg (TF::NegOp)
Computes numerical negative value element-wise.

### Description:

I.e., \\(y = -x\\).

### Operands:
1. `x`: tensor of bfloat16 type or 16-bit float or 32-bit float or 64-bit float or 32-bit integer or 64-bit integer or complex128 type or complex64 type values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `T` | `Attribute` | derived attribute attribute |

### Results:
1. `y`: tensor of bfloat16 type or 16-bit float or 32-bit float or 64-bit float or 32-bit integer or 64-bit integer or complex128 type or complex64 type values

## tf.NoOp (TF::NoOp)
Does nothing. Only useful as a placeholder for control edges.

### Description:


### Operands:

### Attributes:

### Results:

## tf.NotEqual (TF::NotEqualOp)
Returns the truth value of (x != y) element-wise.

### Description:

*NOTE*: `NotEqual` supports broadcasting. More about broadcasting
[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)

### Operands:
1. `x`: tensor of bfloat16 type or 16-bit float or 32-bit float or 64-bit float or 1-bit integer or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or complex128 type or complex64 type or TensorFlow string type values
1. `y`: tensor of bfloat16 type or 16-bit float or 32-bit float or 64-bit float or 1-bit integer or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or complex128 type or complex64 type or TensorFlow string type values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `T` | `Attribute` | derived attribute attribute |

### Results:
1. `z`: tensor of 1-bit integer values

## tf.Pack (TF::PackOp)

Packs a list of `N` rank-`R` tensors into one rank-`(R+1)` tensor.
  

### Description:

Packs the `N` tensors in `values` into a tensor with rank one higher than each
tensor in `values`, by packing them along the `axis` dimension.
Given a list of tensors of shape `(A, B, C)`;

if `axis == 0` then the `output` tensor will have the shape `(N, A, B, C)`.
if `axis == 1` then the `output` tensor will have the shape `(A, N, B, C)`.
Etc.

For example:

```
# 'x' is [1, 4]
# 'y' is [2, 5]
# 'z' is [3, 6]
pack([x, y, z]) => [[1, 4], [2, 5], [3, 6]]  # Pack along first dim.
pack([x, y, z], axis=1) => [[1, 2, 3], [4, 5, 6]]
```

This is the opposite of `unpack`.

### Operands:
1. `values`: tensor of tf.dtype values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `N` | `IntegerAttr` | 64-bit integer attribute whose minimal value is 1 attribute |
| `axis` | `IntegerAttr` | 64-bit integer attribute attribute |
| `T` | `Attribute` | derived attribute attribute |

### Results:
1. `output`: tensor of tf.dtype values

## tf.Pad (TF::PadOp)
Pads a tensor with zeros.

### Description:

This operation pads a `input` with zeros according to the `paddings` you
specify. `paddings` is an integer tensor with shape `[Dn, 2]`, where n is the
rank of `input`. For each dimension D of `input`, `paddings[D, 0]` indicates
how many zeros to add before the contents of `input` in that dimension, and
`paddings[D, 1]` indicates how many zeros to add after the contents of `input`
in that dimension.

The padded size of each dimension D of the output is:

`paddings(D, 0) + input.dim_size(D) + paddings(D, 1)`

For example:

```
# 't' is [[1, 1], [2, 2]]
# 'paddings' is [[1, 1], [2, 2]]
# rank of 't' is 2
pad(t, paddings) ==> [[0, 0, 0, 0, 0, 0]
                      [0, 0, 1, 1, 0, 0]
                      [0, 0, 2, 2, 0, 0]
                      [0, 0, 0, 0, 0, 0]]
```

### Operands:
1. `input`: tensor of tf.dtype values
1. `paddings`: tensor of 32/64-bit integer values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `T` | `Attribute` | derived attribute attribute |
| `Tpaddings` | `Attribute` | derived attribute attribute |

### Results:
1. `output`: tensor of tf.dtype values

## tf.PadV2 (TF::PadV2Op)
Pads a tensor.

### Description:

This operation pads `input` according to the `paddings` and `constant_values`
you specify. `paddings` is an integer tensor with shape `[Dn, 2]`, where n is
the rank of `input`. For each dimension D of `input`, `paddings[D, 0]` indicates
how many padding values to add before the contents of `input` in that dimension,
and `paddings[D, 1]` indicates how many padding values to add after the contents
of `input` in that dimension. `constant_values` is a scalar tensor of the same
type as `input` that indicates the value to use for padding `input`.

The padded size of each dimension D of the output is:

`paddings(D, 0) + input.dim_size(D) + paddings(D, 1)`

For example:

```
# 't' is [[1, 1], [2, 2]]
# 'paddings' is [[1, 1], [2, 2]]
# 'constant_values' is 0
# rank of 't' is 2
pad(t, paddings) ==> [[0, 0, 0, 0, 0, 0]
                      [0, 0, 1, 1, 0, 0]
                      [0, 0, 2, 2, 0, 0]
                      [0, 0, 0, 0, 0, 0]]
```

### Operands:
1. `input`: tensor of tf.dtype values
1. `paddings`: tensor of 32/64-bit integer values
1. `constant_values`: tensor of tf.dtype values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `T` | `Attribute` | derived attribute attribute |
| `Tpaddings` | `Attribute` | derived attribute attribute |

### Results:
1. `output`: tensor of tf.dtype values

## tf.Placeholder.input (TF::PlaceholderInputOp)
PlaceholderInput op

### Description:

Inserts a placeholder for a tensor that will be always fed.

### Operands:
1. `arg`: tensor of tf.dtype values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `min` | `FloatAttr` | 32-bit float attribute attribute |
| `max` | `FloatAttr` | 32-bit float attribute attribute |
| `type` | `TypeAttr` | integer type attribute |
| `dtype` | `Attribute` | derived attribute attribute |

### Results:
1. `output`: tensor of tf.dtype values

## tf.Placeholder (TF::PlaceholderOp)
Placeholder op

### Description:

Inserts a placeholder for a tensor that will be always fed.

### Operands:

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `dtype` | `Attribute` | derived attribute attribute |

### Results:
1. `output`: tensor of tf.dtype values

## tf.QuantizeAndDequantize (TF::QuantizeAndDequantizeOp)
Use QuantizeAndDequantizeV2 instead.

### Description:


### Operands:
1. `input`: tensor of floating-point values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `signed_input` | `BoolAttr` | bool attribute attribute |
| `num_bits` | `IntegerAttr` | 64-bit integer attribute attribute |
| `range_given` | `BoolAttr` | bool attribute attribute |
| `input_min` | `FloatAttr` | 32-bit float attribute attribute |
| `input_max` | `FloatAttr` | 32-bit float attribute attribute |
| `T` | `Attribute` | derived attribute attribute |

### Results:
1. `output`: tensor of floating-point values

## tf.QuantizeAndDequantizeV2 (TF::QuantizeAndDequantizeV2Op)
Quantizes then dequantizes a tensor.

### Description:

This op simulates the precision loss from the quantized forward pass by:

1. Quantizing the tensor to fixed point numbers, which should match the target
   quantization method when it is used in inference.
2. Dequantizing it back to floating point numbers for the following ops, most
   likely matmul.

There are different ways to quantize. This version uses only scaling, so 0.0
maps to 0.

From the specified 'num_bits' in the quantized output type, it determines
minimum and maximum representable quantized values.

e.g.

*   [-128, 127] for signed, num_bits = 8, or
*   [0, 255] for unsigned, num_bits = 8.

If range_given == False, the initial input_min, input_max will be determined
automatically as the minimum and maximum values in the input tensor, otherwise
the specified values of input_min, input_max are used.

Note: If the input_min, input_max are specified, they do not need to equal the
actual minimum and maximum values in the tensor. e.g. in some cases it may be
beneficial to specify these values such that the low probability extremes of the
input distribution are clipped.

This op determines the maximum scale_factor that would map the initial
[input_min, input_max] range to a range that lies within the representable
quantized range.

It determines the scale from one of input_min and input_max, then updates the
other one to maximize the representable range.

e.g.

*   if the output is signed, num_bits = 8, [input_min, input_max] = [-10.0,
    5.0]: it would use a scale_factor of -128 / -10.0 = 12.8 In this case, it
    would update input_max to be 127 / 12.8 = 9.921875
*   if the output is signed, num_bits = 8, [input_min, input_max] = [-10.0,
    10.0]: it would use a scale_factor of 127 / 10.0 = 12.7 In this case, it
    would update input_min to be 128.0 / 12.7 = -10.07874
*   if the output is unsigned, input_min is forced to be 0, and only the
    specified input_max is used.

After determining the scale_factor and updating the input range, it applies the
following to each value in the 'input' tensor.

output = round(clamp(value, input_min, input_max) * scale_factor) / scale_factor.

The above round function rounds the value based on the given round_mode.

### Operands:
1. `input`: tensor of floating-point values
1. `input_min`: tensor of floating-point values
1. `input_max`: tensor of floating-point values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `signed_input` | `BoolAttr` | bool attribute attribute |
| `num_bits` | `IntegerAttr` | 64-bit integer attribute attribute |
| `range_given` | `BoolAttr` | bool attribute attribute |
| `round_mode` | `StringAttr` | string attribute whose value is HALF_TO_EVEN, or HALF_UP attribute |
| `narrow_range` | `BoolAttr` | bool attribute attribute |
| `T` | `Attribute` | derived attribute attribute |

### Results:
1. `output`: tensor of floating-point values

## tf.QuantizeAndDequantizeV3 (TF::QuantizeAndDequantizeV3Op)
Quantizes then dequantizes a tensor.

### Description:

This is almost identical to QuantizeAndDequantizeV2, except that num_bits is a
tensor, so its value can change during training.

### Operands:
1. `input`: tensor of floating-point values
1. `input_min`: tensor of floating-point values
1. `input_max`: tensor of floating-point values
1. `num_bits`: tensor of 32-bit integer values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `signed_input` | `BoolAttr` | bool attribute attribute |
| `range_given` | `BoolAttr` | bool attribute attribute |
| `narrow_range` | `BoolAttr` | bool attribute attribute |
| `T` | `Attribute` | derived attribute attribute |

### Results:
1. `output`: tensor of floating-point values

## tf.RandomUniform (TF::RandomUniformOp)
Outputs random values from a uniform distribution.

### Description:

The generated values follow a uniform distribution in the range `[0, 1)`. The
lower bound 0 is included in the range, while the upper bound 1 is excluded.

### Operands:
1. `shape`: tensor of 32/64-bit integer values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `seed` | `IntegerAttr` | 64-bit integer attribute attribute |
| `seed2` | `IntegerAttr` | 64-bit integer attribute attribute |
| `T` | `Attribute` | derived attribute attribute |
| `dtype` | `Attribute` | derived attribute attribute |

### Results:
1. `output`: tensor of floating-point values

## tf.Range (TF::RangeOp)
Creates a sequence of numbers.

### Description:

This operation creates a sequence of numbers that begins at `start` and
extends by increments of `delta` up to but not including `limit`.

For example:

```
# 'start' is 3
# 'limit' is 18
# 'delta' is 3
tf.range(start, limit, delta) ==> [3, 6, 9, 12, 15]
```

### Operands:
1. `start`: tensor of bfloat16 type or 32-bit float or 64-bit float or 32-bit integer or 64-bit integer values
1. `limit`: tensor of bfloat16 type or 32-bit float or 64-bit float or 32-bit integer or 64-bit integer values
1. `delta`: tensor of bfloat16 type or 32-bit float or 64-bit float or 32-bit integer or 64-bit integer values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `Tidx` | `Attribute` | derived attribute attribute |

### Results:
1. `output`: tensor of bfloat16 type or 32-bit float or 64-bit float or 32-bit integer or 64-bit integer values

## tf.Rank (TF::RankOp)
Returns the rank of a tensor.

### Description:

This operation returns an integer representing the rank of `input`.

For example:

```
# 't' is [[[1, 1, 1], [2, 2, 2]], [[3, 3, 3], [4, 4, 4]]]
# shape of tensor 't' is [2, 2, 3]
rank(t) ==> 3
```

**Note**: The rank of a tensor is not the same as the rank of a matrix. The rank
of a tensor is the number of indices required to uniquely select each element
of the tensor. Rank is also known as "order", "degree", or "ndims."

### Operands:
1. `input`: tensor of tf.dtype values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `T` | `Attribute` | derived attribute attribute |

### Results:
1. `output`: tensor of 32-bit integer values

## tf.RealDiv (TF::RealDivOp)
Returns x / y element-wise for real types.

### Description:

If `x` and `y` are reals, this will return the floating-point division.

*NOTE*: `Div` supports broadcasting. More about broadcasting
[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)

### Operands:
1. `x`: tensor of number values
1. `y`: tensor of number values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `T` | `Attribute` | derived attribute attribute |

### Results:
1. `z`: tensor of number values

## tf.Reciprocal (TF::ReciprocalOp)
Computes the reciprocal of x element-wise.

### Description:

I.e., \\(y = 1 / x\\).

### Operands:
1. `x`: tensor of bfloat16 type or 16-bit float or 32-bit float or 64-bit float or 32-bit integer or 64-bit integer or complex128 type or complex64 type values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `T` | `Attribute` | derived attribute attribute |

### Results:
1. `y`: tensor of bfloat16 type or 16-bit float or 32-bit float or 64-bit float or 32-bit integer or 64-bit integer or complex128 type or complex64 type values

## tf.Relu6 (TF::Relu6Op)
Computes rectified linear 6: `min(max(features, 0), 6)`.

### Description:


### Operands:
1. `features`: tensor of 8/16/32/64-bit integer or floating-point values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `T` | `Attribute` | derived attribute attribute |

### Results:
1. `activations`: tensor of 8/16/32/64-bit integer or floating-point values

## tf.Relu (TF::ReluOp)
Computes rectified linear: `max(features, 0)`.

### Description:


### Operands:
1. `features`: tensor of 8/16/32/64-bit integer or floating-point values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `T` | `Attribute` | derived attribute attribute |

### Results:
1. `activations`: tensor of 8/16/32/64-bit integer or floating-point values

## tf.Reshape (TF::ReshapeOp)
Reshapes a tensor.

### Description:

Given `tensor`, this operation returns a tensor that has the same values
as `tensor` with shape `shape`.

If one component of `shape` is the special value -1, the size of that dimension
is computed so that the total size remains constant.  In particular, a `shape`
of `[-1]` flattens into 1-D.  At most one component of `shape` can be -1.

If `shape` is 1-D or higher, then the operation returns a tensor with shape
`shape` filled with the values of `tensor`. In this case, the number of elements
implied by `shape` must be the same as the number of elements in `tensor`.

For example:

```
# tensor 't' is [1, 2, 3, 4, 5, 6, 7, 8, 9]
# tensor 't' has shape [9]
reshape(t, [3, 3]) ==> [[1, 2, 3],
                        [4, 5, 6],
                        [7, 8, 9]]

# tensor 't' is [[[1, 1], [2, 2]],
#                [[3, 3], [4, 4]]]
# tensor 't' has shape [2, 2, 2]
reshape(t, [2, 4]) ==> [[1, 1, 2, 2],
                        [3, 3, 4, 4]]

# tensor 't' is [[[1, 1, 1],
#                 [2, 2, 2]],
#                [[3, 3, 3],
#                 [4, 4, 4]],
#                [[5, 5, 5],
#                 [6, 6, 6]]]
# tensor 't' has shape [3, 2, 3]
# pass '[-1]' to flatten 't'
reshape(t, [-1]) ==> [1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6]

# -1 can also be used to infer the shape

# -1 is inferred to be 9:
reshape(t, [2, -1]) ==> [[1, 1, 1, 2, 2, 2, 3, 3, 3],
                         [4, 4, 4, 5, 5, 5, 6, 6, 6]]
# -1 is inferred to be 2:
reshape(t, [-1, 9]) ==> [[1, 1, 1, 2, 2, 2, 3, 3, 3],
                         [4, 4, 4, 5, 5, 5, 6, 6, 6]]
# -1 is inferred to be 3:
reshape(t, [ 2, -1, 3]) ==> [[[1, 1, 1],
                              [2, 2, 2],
                              [3, 3, 3]],
                             [[4, 4, 4],
                              [5, 5, 5],
                              [6, 6, 6]]]

# tensor 't' is [7]
# shape `[]` reshapes to a scalar
reshape(t, []) ==> 7
```

### Operands:
1. `tensor`: tensor of tf.dtype values
1. `shape`: tensor of 32/64-bit integer values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `T` | `Attribute` | derived attribute attribute |
| `Tshape` | `Attribute` | derived attribute attribute |

### Results:
1. `output`: tensor of tf.dtype values

## tf.ResizeBilinear (TF::ResizeBilinearOp)
Resize `images` to `size` using bilinear interpolation.

### Description:

Input images can be of different types but output images are always float.

### Operands:
1. `images`: tensor of 8/16/32/64-bit integer or floating-point values
1. `size`: tensor of 32-bit integer values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `align_corners` | `BoolAttr` | bool attribute attribute |
| `half_pixel_centers` | `BoolAttr` | bool attribute attribute |
| `T` | `Attribute` | derived attribute attribute |

### Results:
1. `resized_images`: tensor of 32-bit float values

## tf.ReverseV2 (TF::ReverseV2Op)
Reverses specific dimensions of a tensor.

### Description:

NOTE `tf.reverse` has now changed behavior in preparation for 1.0.
`tf.reverse_v2` is currently an alias that will be deprecated before TF 1.0.

Given a `tensor`, and a `int32` tensor `axis` representing the set of
dimensions of `tensor` to reverse. This operation reverses each dimension
`i` for which there exists `j` s.t. `axis[j] == i`.

`tensor` can have up to 8 dimensions. The number of dimensions specified
in `axis` may be 0 or more entries. If an index is specified more than
once, a InvalidArgument error is raised.

For example:

```
# tensor 't' is [[[[ 0,  1,  2,  3],
#                  [ 4,  5,  6,  7],
#                  [ 8,  9, 10, 11]],
#                 [[12, 13, 14, 15],
#                  [16, 17, 18, 19],
#                  [20, 21, 22, 23]]]]
# tensor 't' shape is [1, 2, 3, 4]

# 'dims' is [3] or 'dims' is [-1]
reverse(t, dims) ==> [[[[ 3,  2,  1,  0],
                        [ 7,  6,  5,  4],
                        [ 11, 10, 9, 8]],
                       [[15, 14, 13, 12],
                        [19, 18, 17, 16],
                        [23, 22, 21, 20]]]]

# 'dims' is '[1]' (or 'dims' is '[-3]')
reverse(t, dims) ==> [[[[12, 13, 14, 15],
                        [16, 17, 18, 19],
                        [20, 21, 22, 23]
                       [[ 0,  1,  2,  3],
                        [ 4,  5,  6,  7],
                        [ 8,  9, 10, 11]]]]

# 'dims' is '[2]' (or 'dims' is '[-2]')
reverse(t, dims) ==> [[[[8, 9, 10, 11],
                        [4, 5, 6, 7],
                        [0, 1, 2, 3]]
                       [[20, 21, 22, 23],
                        [16, 17, 18, 19],
                        [12, 13, 14, 15]]]]
```

### Operands:
1. `tensor`: tensor of bfloat16 type or 16-bit float or 32-bit float or 64-bit float or 1-bit integer or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or complex128 type or complex64 type or TensorFlow string type values
1. `axis`: tensor of 32/64-bit integer values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `T` | `Attribute` | derived attribute attribute |
| `Tidx` | `Attribute` | derived attribute attribute |

### Results:
1. `output`: tensor of bfloat16 type or 16-bit float or 32-bit float or 64-bit float or 1-bit integer or 16-bit integer or 32-bit integer or 64-bit integer or 8-bit integer or complex128 type or complex64 type or TensorFlow string type values

## tf.Rsqrt (TF::RsqrtOp)
Computes reciprocal of square root of x element-wise.

### Description:

I.e., \\(y = 1 / \sqrt{x}\\).

### Operands:
1. `x`: tensor of floating-point or 64/128-bit complex type values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `T` | `Attribute` | derived attribute attribute |

### Results:
1. `y`: tensor of floating-point or 64/128-bit complex type values

## tf.Select (TF::SelectOp)
Selects elements from `x` or `y`, depending on `condition`.

### Description:

The `x`, and `y` tensors must all have the same shape, and the
output will also have that shape.

The `condition` tensor must be a scalar if `x` and `y` are scalars.
If `x` and `y` are vectors or higher rank, then `condition` must be either a
scalar, a vector with size matching the first dimension of `x`, or must have
the same shape as `x`.

The `condition` tensor acts as a mask that chooses, based on the value at each
element, whether the corresponding element / row in the output should be
taken from `x` (if true) or `y` (if false).

If `condition` is a vector and `x` and `y` are higher rank matrices, then
it chooses which row (outer dimension) to copy from `x` and `y`.
If `condition` has the same shape as `x` and `y`, then it chooses which
element to copy from `x` and `y`.

For example:

```python
# 'condition' tensor is [[True,  False]
#                        [False, True]]
# 't' is [[1, 2],
#         [3, 4]]
# 'e' is [[5, 6],
#         [7, 8]]
select(condition, t, e)  # => [[1, 6], [7, 4]]


# 'condition' tensor is [True, False]
# 't' is [[1, 2],
#         [3, 4]]
# 'e' is [[5, 6],
#         [7, 8]]
select(condition, t, e) ==> [[1, 2],
                             [7, 8]]

```

### Operands:
1. `condition`: tensor of 1-bit integer values
1. `t`: tensor of tf.dtype values
1. `e`: tensor of tf.dtype values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `T` | `Attribute` | derived attribute attribute |

### Results:
1. `output`: tensor of tf.dtype values

## tf.Shape (TF::ShapeOp)
Returns the shape of a tensor.

### Description:

This operation returns a 1-D integer tensor representing the shape of `input`.

For example:

```
# 't' is [[[1, 1, 1], [2, 2, 2]], [[3, 3, 3], [4, 4, 4]]]
shape(t) ==> [2, 2, 3]
```

### Operands:
1. `input`: tensor of tf.dtype values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `T` | `Attribute` | derived attribute attribute |
| `out_type` | `Attribute` | derived attribute attribute |

### Results:
1. `output`: tensor of 32/64-bit integer values

## tf.Sigmoid (TF::SigmoidOp)
Computes sigmoid of `x` element-wise.

### Description:

Specifically, `y = 1 / (1 + exp(-x))`.

### Operands:
1. `x`: tensor of floating-point or 64/128-bit complex type values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `T` | `Attribute` | derived attribute attribute |

### Results:
1. `y`: tensor of floating-point or 64/128-bit complex type values

## tf.Sin (TF::SinOp)
Computes sin of x element-wise.

### Description:


### Operands:
1. `x`: tensor of floating-point or 64/128-bit complex type values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `T` | `Attribute` | derived attribute attribute |

### Results:
1. `y`: tensor of floating-point or 64/128-bit complex type values

## tf.Slice (TF::SliceOp)
Return a slice from 'input'.

### Description:

The output tensor is a tensor with dimensions described by 'size'
whose values are extracted from 'input' starting at the offsets in
'begin'.

*Requirements*:
  0 <= begin[i] <= begin[i] + size[i] <= Di  for i in [0, n)

### Operands:
1. `input`: tensor of tf.dtype values
1. `begin`: tensor of 32/64-bit integer values
1. `size`: tensor of 32/64-bit integer values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `T` | `Attribute` | derived attribute attribute |
| `Index` | `Attribute` | derived attribute attribute |

### Results:
1. `output`: tensor of tf.dtype values

## tf.Softmax (TF::SoftmaxOp)
Computes softmax activations.

### Description:

For each batch `i` and class `j` we have

    $$softmax[i, j] = exp(logits[i, j]) / sum_j(exp(logits[i, j]))$$

### Operands:
1. `logits`: tensor of floating-point values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `T` | `Attribute` | derived attribute attribute |

### Results:
1. `softmax`: tensor of floating-point values

## tf.SpaceToBatchND (TF::SpaceToBatchNDOp)
SpaceToBatch for N-D tensors of type T.

### Description:

This operation divides "spatial" dimensions `[1, ..., M]` of the input into a
grid of blocks of shape `block_shape`, and interleaves these blocks with the
"batch" dimension (0) such that in the output, the spatial dimensions
`[1, ..., M]` correspond to the position within the grid, and the batch
dimension combines both the position within a spatial block and the original
batch position.  Prior to division into blocks, the spatial dimensions of the
input are optionally zero padded according to `paddings`.  See below for a
precise description.

### Operands:
1. `input`: tensor of tf.dtype values
1. `block_shape`: tensor of 32/64-bit integer values
1. `paddings`: tensor of 32/64-bit integer values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `T` | `Attribute` | derived attribute attribute |
| `Tpaddings` | `Attribute` | derived attribute attribute |
| `Tblock_shape` | `Attribute` | derived attribute attribute |

### Results:
1. `output`: tensor of tf.dtype values

## tf.Split (TF::SplitOp)
Splits a tensor into `num_split` tensors along one dimension.

### Description:


### Operands:
1. `split_dim`: tensor of 32-bit integer values
1. `value`: tensor of tf.dtype values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `num_split` | `IntegerAttr` | 64-bit integer attribute whose minimal value is 1 attribute |
| `T` | `Attribute` | derived attribute attribute |

### Results:
1. `output`: tensor of tf.dtype values

## tf.SplitV (TF::SplitVOp)
Splits a tensor into `num_split` tensors along one dimension.

### Description:


### Operands:
1. `value`: tensor of tf.dtype values
1. `size_splits`: tensor of 32/64-bit integer values
1. `split_dim`: tensor of 32-bit integer values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `num_split` | `IntegerAttr` | 64-bit integer attribute whose minimal value is 1 attribute |
| `Tlen` | `Attribute` | derived attribute attribute |
| `T` | `Attribute` | derived attribute attribute |

### Results:
1. `output`: tensor of tf.dtype values

## tf.Sqrt (TF::SqrtOp)
Computes square root of x element-wise.

### Description:

I.e., \\(y = \sqrt{x} = x^{1/2}\\).

### Operands:
1. `x`: tensor of floating-point or 64/128-bit complex type values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `T` | `Attribute` | derived attribute attribute |

### Results:
1. `y`: tensor of floating-point or 64/128-bit complex type values

## tf.Square (TF::SquareOp)
Computes square of x element-wise.

### Description:

I.e., \\(y = x * x = x^2\\).

### Operands:
1. `x`: tensor of bfloat16 type or 16-bit float or 32-bit float or 64-bit float or 32-bit integer or 64-bit integer or complex128 type or complex64 type values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `T` | `Attribute` | derived attribute attribute |

### Results:
1. `y`: tensor of bfloat16 type or 16-bit float or 32-bit float or 64-bit float or 32-bit integer or 64-bit integer or complex128 type or complex64 type values

## tf.SquaredDifference (TF::SquaredDifferenceOp)
Returns (x - y)(x - y) element-wise.

### Description:

*NOTE*: `SquaredDifference` supports broadcasting. More about broadcasting
[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)

### Operands:
1. `x`: tensor of bfloat16 type or 16-bit float or 32-bit float or 64-bit float or 32-bit integer or 64-bit integer or complex128 type or complex64 type values
1. `y`: tensor of bfloat16 type or 16-bit float or 32-bit float or 64-bit float or 32-bit integer or 64-bit integer or complex128 type or complex64 type values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `T` | `Attribute` | derived attribute attribute |

### Results:
1. `z`: tensor of bfloat16 type or 16-bit float or 32-bit float or 64-bit float or 32-bit integer or 64-bit integer or complex128 type or complex64 type values

## tf.Squeeze (TF::SqueezeOp)
Removes dimensions of size 1 from the shape of a tensor.

### Description:

Given a tensor `input`, this operation returns a tensor of the same type with
all dimensions of size 1 removed. If you don't want to remove all size 1
dimensions, you can remove specific size 1 dimensions by specifying
`axis`.

For example:

```
# 't' is a tensor of shape [1, 2, 1, 3, 1, 1]
shape(squeeze(t)) ==> [2, 3]
```

Or, to remove specific size 1 dimensions:

```
# 't' is a tensor of shape [1, 2, 1, 3, 1, 1]
shape(squeeze(t, [2, 4])) ==> [1, 2, 3, 1]
```

### Operands:
1. `input`: tensor of tf.dtype values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `squeeze_dims` | `ArrayAttr` | 64-bit integer array attribute attribute |
| `T` | `Attribute` | derived attribute attribute |

### Results:
1. `output`: tensor of tf.dtype values

## tf.StridedSlice (TF::StridedSliceOp)
Return a strided slice from `input`.

### Description:

Note, most python users will want to use the Python `Tensor.__getitem__`
or `Variable.__getitem__` rather than this op directly.

The goal of this op is to produce a new tensor with a subset of
the elements from the `n` dimensional `input` tensor. The subset is chosen using
a sequence of `m` sparse range specifications encoded into the arguments
of this function. Note, in some cases
`m` could be equal to `n`, but this need not be the case. Each
range specification entry can be one of the following:

- An ellipsis (...). Ellipses are used to imply zero or more
  dimensions of full-dimension selection and are produced using
  `ellipsis_mask`. For example, `foo[...]` is the identity slice.

- A new axis. This is used to insert a new shape=1 dimension and is
  produced using `new_axis_mask`. For example, `foo[:, ...]` where
  `foo` is shape `(3, 4)` produces a `(1, 3, 4)` tensor.


- A range `begin:end:stride`. This is used to specify how much to choose from
  a given dimension. `stride` can be any integer but 0.  `begin` is an integer
  which represents the index of the first value to select while `end` represents
  the index of the last value to select. The number of values selected in each
  dimension is `end - begin` if `stride > 0` and `begin - end` if `stride < 0`.
  `begin` and `end` can be negative where `-1` is the last element, `-2` is
  the second to last. `begin_mask` controls whether to replace the explicitly
  given `begin` with an implicit effective value of `0` if `stride > 0` and
  `-1` if `stride < 0`. `end_mask` is analogous but produces the number
  required to create the largest open interval. For example, given a shape
  `(3,)` tensor `foo[:]`, the effective `begin` and `end` are `0` and `3`. Do
  not assume this is equivalent to `foo[0:-1]` which has an effective `begin`
  and `end` of `0` and `2`. Another example is `foo[-2::-1]` which reverses the
  first dimension of a tensor while dropping the last two (in the original
  order elements). For example `foo = [1,2,3,4]; foo[-2::-1]` is `[4,3]`.

- A single index. This is used to keep only elements that have a given
  index. For example (`foo[2, :]` on a shape `(5,6)` tensor produces a
  shape `(6,)` tensor. This is encoded in `begin` and `end` and
  `shrink_axis_mask`.

Each conceptual range specification is encoded in the op's argument. This
encoding is best understand by considering a non-trivial example. In
particular,
`foo[1, 2:4, None, ..., :-3:-1, :]` will be encoded as

```
begin = [1, 2, x, x, 0, x] # x denotes don't care (usually 0)
end = [2, 4, x, x, -3, x]
strides = [1, 1, x, x, -1, 1]
begin_mask = 1<<4 | 1 << 5 = 48
end_mask = 1<<5 = 32
ellipsis_mask = 1<<3 = 8
new_axis_mask = 1<<2 4
shrink_axis_mask = 1<<0
```

In this case if `foo.shape` is (5, 5, 5, 5, 5, 5) the final shape of
the slice becomes (2, 1, 5, 5, 2, 5).
Let us walk step by step through each argument specification.

1.  The first argument in the example slice is turned into `begin = 1` and
`end = begin + 1 = 2`. To disambiguate from the original spec `2:4` we
also set the appropriate bit in `shrink_axis_mask`.

2. `2:4` is contributes 2, 4, 1 to begin, end, and stride. All masks have
zero bits contributed.

3. None is a synonym for `tf.newaxis`. This means insert a dimension of size 1
dimension in the final shape. Dummy values are contributed to begin,
end and stride, while the new_axis_mask bit is set.

4. `...` grab the full ranges from as many dimensions as needed to
fully specify a slice for every dimension of the input shape.

5. `:-3:-1` shows the use of negative indices. A negative index `i` associated
with a dimension that has shape `s` is converted to a positive index
`s + i`. So `-1` becomes `s-1` (i.e. the last element). This conversion
is done internally so begin, end and strides receive x, -3, and -1.
The appropriate begin_mask bit is set to indicate the start range is the
full range (ignoring the x).

6. `:` indicates that the entire contents of the corresponding dimension
is selected. This is equivalent to `::` or `0::1`. begin, end, and strides
receive 0, 0, and 1, respectively. The appropriate bits in `begin_mask` and
`end_mask` are also set.

*Requirements*:
  `0 != strides[i] for i in [0, m)`
  `ellipsis_mask must be a power of two (only one ellipsis)`

### Operands:
1. `input`: tensor of tf.dtype values
1. `begin`: tensor of 32/64-bit integer values
1. `end`: tensor of 32/64-bit integer values
1. `strides`: tensor of 32/64-bit integer values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `begin_mask` | `IntegerAttr` | 64-bit integer attribute attribute |
| `end_mask` | `IntegerAttr` | 64-bit integer attribute attribute |
| `ellipsis_mask` | `IntegerAttr` | 64-bit integer attribute attribute |
| `new_axis_mask` | `IntegerAttr` | 64-bit integer attribute attribute |
| `shrink_axis_mask` | `IntegerAttr` | 64-bit integer attribute attribute |
| `T` | `Attribute` | derived attribute attribute |
| `Index` | `Attribute` | derived attribute attribute |

### Results:
1. `output`: tensor of tf.dtype values

## tf.Sub (TF::SubOp)
Returns x - y element-wise.

### Description:

*NOTE*: `Subtract` supports broadcasting. More about broadcasting
[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)

### Operands:
1. `x`: tensor of number values
1. `y`: tensor of number values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `T` | `Attribute` | derived attribute attribute |

### Results:
1. `z`: tensor of number values

## tf.Sum (TF::SumOp)
Computes the sum of elements across dimensions of a tensor.

### Description:

Reduces `input` along the dimensions given in `axis`. Unless
`keep_dims` is true, the rank of the tensor is reduced by 1 for each entry in
`axis`. If `keep_dims` is true, the reduced dimensions are
retained with length 1.

### Operands:
1. `input`: tensor of number values
1. `reduction_indices`: tensor of 32/64-bit integer values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `keep_dims` | `BoolAttr` | bool attribute attribute |
| `T` | `Attribute` | derived attribute attribute |
| `Tidx` | `Attribute` | derived attribute attribute |

### Results:
1. `output`: tensor of number values

## tf.TensorListFromTensor (TF::TensorListFromTensorOp)

Creates a TensorList which, when stacked, has the value of `tensor`.
  

### Description:

Each tensor in the result list corresponds to one row of the input tensor.

tensor: The input tensor.
output_handle: The list.

### Operands:
1. `tensor`: tensor of tf.dtype values
1. `element_shape`: tensor of 32/64-bit integer values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `shape_type` | `Attribute` | derived attribute attribute |
| `element_dtype` | `Attribute` | derived attribute attribute |

### Results:
1. `output_handle`: tensor of TensorFlow variant type values

## tf.TensorListGetItem (TF::TensorListGetItemOp)


### Description:


### Operands:
1. `input_handle`: tensor of TensorFlow variant type values
1. `index`: tensor of 32-bit integer values
1. `element_shape`: tensor of 32-bit integer values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `element_dtype` | `Attribute` | derived attribute attribute |

### Results:
1. `item`: tensor of tf.dtype values

## tf.TensorListReserve (TF::TensorListReserveOp)
List of the given size with empty elements.

### Description:

element_shape: the shape of the future elements of the list
num_elements: the number of elements to reserve
handle: the output list
element_dtype: the desired type of elements in the list.

### Operands:
1. `element_shape`: tensor of 32/64-bit integer values
1. `num_elements`: tensor of 32-bit integer values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `element_dtype` | `TypeAttr` | any type attribute attribute |
| `shape_type` | `Attribute` | derived attribute attribute |

### Results:
1. `handle`: tensor of TensorFlow variant type values

## tf.TensorListSetItem (TF::TensorListSetItemOp)


### Description:


### Operands:
1. `input_handle`: tensor of TensorFlow variant type values
1. `index`: tensor of 32-bit integer values
1. `item`: tensor of tf.dtype values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `element_dtype` | `Attribute` | derived attribute attribute |

### Results:
1. `output_handle`: tensor of TensorFlow variant type values

## tf.TensorListStack (TF::TensorListStackOp)
Stacks all tensors in the list.

### Description:

Requires that all tensors have the same shape.

input_handle: the input list
tensor: the gathered result
num_elements: optional. If not -1, the number of elements in the list.

### Operands:
1. `input_handle`: tensor of TensorFlow variant type values
1. `element_shape`: tensor of 32-bit integer values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `num_elements` | `IntegerAttr` | 64-bit integer attribute attribute |
| `element_dtype` | `Attribute` | derived attribute attribute |

### Results:
1. `tensor`: tensor of tf.dtype values

## tf.TopKV2 (TF::TopKV2Op)

Finds values and indices of the `k` largest elements for the last dimension.
  

### Description:

If the input is a vector (rank-1), finds the `k` largest entries in the vector
and outputs their values and indices as vectors.  Thus `values[j]` is the
`j`-th largest entry in `input`, and its index is `indices[j]`.

For matrices (resp. higher rank input), computes the top `k` entries in each
row (resp. vector along the last dimension).  Thus,

    values.shape = indices.shape = input.shape[:-1] + [k]

If two elements are equal, the lower-index element appears first.

### Operands:
1. `input`: tensor of 8/16/32/64-bit integer or floating-point values
1. `k`: tensor of 32-bit integer values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `sorted` | `BoolAttr` | bool attribute attribute |
| `T` | `Attribute` | derived attribute attribute |

### Results:
1. `values`: tensor of 8/16/32/64-bit integer or floating-point values
1. `indices`: tensor of 32-bit integer values

## tf.Transpose (TF::TransposeOp)
Shuffle dimensions of x according to a permutation.

### Description:

The output `y` has the same rank as `x`. The shapes of `x` and `y` satisfy:
  `y.shape[i] == x.shape[perm[i]] for i in [0, 1, ..., rank(x) - 1]`

### Operands:
1. `x`: tensor of tf.dtype values
1. `perm`: tensor of 32/64-bit integer values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `T` | `Attribute` | derived attribute attribute |
| `Tperm` | `Attribute` | derived attribute attribute |

### Results:
1. `y`: tensor of tf.dtype values

## tf.TruncateDiv (TF::TruncateDivOp)
Returns x / y element-wise for integer types.

### Description:

Truncation designates that negative numbers will round fractional quantities
toward zero. I.e. -7 / 5 = -1. This matches C semantics but it is different
than Python semantics. See `FloorDiv` for a division function that matches
Python Semantics.

*NOTE*: `TruncateDiv` supports broadcasting. More about broadcasting
[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)

### Operands:
1. `x`: tensor of number values
1. `y`: tensor of number values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `T` | `Attribute` | derived attribute attribute |

### Results:
1. `z`: tensor of number values

## tf.Unpack (TF::UnpackOp)

Unpacks a given dimension of a rank-`R` tensor into `num` rank-`(R-1)` tensors.
  

### Description:

Unpacks `num` tensors from `value` by chipping it along the `axis` dimension.
For example, given a tensor of shape `(A, B, C, D)`;

If `axis == 0` then the i'th tensor in `output` is the slice `value[i, :, :, :]`
  and each tensor in `output` will have shape `(B, C, D)`. (Note that the
  dimension unpacked along is gone, unlike `split`).

If `axis == 1` then the i'th tensor in `output` is the slice `value[:, i, :, :]`
  and each tensor in `output` will have shape `(A, C, D)`.
Etc.

This is the opposite of `pack`.

### Operands:
1. `value`: tensor of tf.dtype values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `num` | `IntegerAttr` | 64-bit integer attribute whose minimal value is 0 attribute |
| `axis` | `IntegerAttr` | 64-bit integer attribute attribute |
| `T` | `Attribute` | derived attribute attribute |

### Results:
1. `output`: tensor of tf.dtype values

## tf.Xdivy (TF::XdivyOp)
Returns 0 if x == 0, and x / y otherwise, elementwise.

### Description:


### Operands:
1. `x`: tensor of 16-bit float or 32-bit float or 64-bit float or complex128 type or complex64 type values
1. `y`: tensor of 16-bit float or 32-bit float or 64-bit float or complex128 type or complex64 type values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `T` | `Attribute` | derived attribute attribute |

### Results:
1. `z`: tensor of 16-bit float or 32-bit float or 64-bit float or complex128 type or complex64 type values

## tf.ZerosLike (TF::ZerosLikeOp)
Returns a tensor of zeros with the same shape and type as x.

### Description:


### Operands:
1. `x`: tensor of tf.dtype values

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `T` | `Attribute` | derived attribute attribute |

### Results:
1. `y`: tensor of tf.dtype values

